# 第1章 计算机基础

**第一部分：微型计算机的发展 (1.1)**

1.  1971年，美国Intel公司研制出 ( ) 微处理器芯片，这被视为微型计算机诞生的标志。
2.  世界上第一台微型计算机是以 ( ) 为核心组成的MCS-4计算机。
3.  微型计算机是以大规模、超大规模集成电路构成的 ( ) 为核心，配以 ( )、( ) 及 ( ) 所组成的计算机。
4.  划分微型计算机发展阶段的主要标志是 ( ) 和 ( )。

**第二部分：微型计算机的常用术语 (1.2)**

5.  计算机中表示数据的最小最基本单位是 ( )，其单位符号是 ( )。
6.  一个字节 (Byte) 由 ( ) 个二进制位组成，通常作为计算机 ( ) 的基本单位，其单位符号是 ( )。
7.  $1KB = 1024 B$，那么 $1MB = ( ) KB = 2^{( )} B$，$1TB = 2^{( )} B$。
8.  微处理器一次可以处理的二进制数的位数称为 ( )，它通常取决于CPU内部 ( ) 的位数和 ( ) 的宽度。
9.  主频，即主时钟频率，表示微处理器的 ( )，其单位是 ( )。

**第三部分：计算机中数据的编码 (1.3)**

10. 计算机中的所有数据，无论是数字、字符还是指令，都采用 ( ) 形式进行编码。
11. 日常生活中我们最常用的是十进制数，计算机硬件能直接识别和处理的是 ( ) 数，而在编程中，除了十进制，还经常使用 ( ) 数。
12. 对于带符号整数，其最高位通常作为 ( )，其中0表示 ( )，1表示 ( )。
13. 对于一个8位二进制数，其原码表示中，`[+0]原` 为 ( )，`[-0]原` 为 ( )，其能表示的数值范围是 ( )。
14. 对于正数，其原码、反码和补码的表示 ( )。
15. 对于负数，其反码的求法是：符号位 ( )，数值位 ( )。
16. 计算机中实际存储和运算带符号数时，普遍采用的是 ( ) 编码方案。
17. 对于负数，其补码的求法是在其反码的基础上 ( )。
18. 对于8位二进制数，其补码表示中，0的表示是唯一的，为 ( )，其能表示的数值范围是 ( )，比原码和反码能多表示一个 ( ) 数。
19. 补码表示法的主要优点是可以将 ( ) 运算转换为 ( ) 运算，从而简化了计算机中运算器的硬件设计，因为只需要 ( ) 即可实现加减运算。
20. 使用补码运算时，$[X-Y]_{补}$ 可以通过计算 ( ) + ( ) 来实现。
21. ASCII码是 ( ) 的简称，主要用于表示 ( )。
22. BCD码是用 ( ) 位二进制数来表示 ( ) 位十进制数。
23. 压缩BCD码用一个字节（8位）可以存放 ( ) 位十进制数。
24. 非压缩BCD码用一个字节（8位）存放 ( ) 位十进制数，其高4位通常补 ( )。

**第四部分：微型计算机的系统组成 (1.4)**

25. 一个完整的微型计算机系统由 ( ) 和 ( ) 两大部分组成。
26. 微型计算机的硬件系统的核心部件是 ( )。
27. CPU主要由运算器、( ) 和 ( ) 组成。
28. CPU中的 ( ) 负责数据的算术运算和逻辑运算，其核心是 ( )。
29. CPU中的 ( ) 是计算机的指挥中心，其主要功能包括取指令、( ) 和执行指令。
30. CPU内部的高速存储单元称为 ( )，其作用是暂存指令、数据和地址，以 ( )。
31. 存储器按功能可分为主存储器（内存）和辅助存储器（外存），其中 ( ) 可以被CPU直接访问。
32. 存储器的每一个存储单元都有一个唯一的编号，称为 ( )，存储单元中存放的信息称为 ( )。
33. I/O接口是连接 ( ) 和 ( ) 的桥梁。I/O接口电路中的寄存器通常称为 ( )。
34. 键盘、鼠标属于计算机的 ( ) 设备，显示器、打印机属于计算机的 ( ) 设备。
35. 系统总线按传输信息的不同可分为地址总线、( ) 和 ( )。
36. 地址总线（AB）用于传递 ( ) 信息，其方向是 ( ) 向的（通常由CPU发出）。
37. 地址总线的位数决定了CPU可直接访问的 ( ) 大小。例如，20条地址线可访问的内存空间为 ( ) B。
38. 数据总线（DB）用于传递 ( ) 信息，其方向是 ( ) 向的。
39. 数据总线的宽度通常与CPU的 ( ) 有关，它决定了一次能够传送的数据位数。
40. 控制总线（CB）用于传递 ( ) 和时序信号，其方向是 ( ) 向的。
41. 操作系统（OS）属于 ( ) 软件，而用户为解决特定应用问题而编写的程序（如Word、Excel）属于 ( ) 软件。

**第五部分：微型计算机的工作过程 (1.5)**

42. 计算机工作的核心任务就是 ( )。
43. 程序是一系列 ( ) 的有序集合，它们以二进制代码的形式按 ( ) 存放在内存的 ( ) 区域中。
44. 计算机执行一条指令通常包含三个基本步骤：首先CPU根据程序计数器(PC)中的地址从内存中 ( ) 到指令寄存器，然后CPU的控制器对指令进行 ( )，最后控制器发出相应的操作命令，由运算器等部件 ( )。

---

**参考答案**

1.  Intel 4004
2.  4004
3.  微处理器或CPU；存储器；输入/输出设备；系统总线
4.  字长；微处理器型号
5.  位 或 bit；b
6.  8；存储器容量；B
7.  1024；20；40
8.  字长；通用寄存器；数据总线
9.  运行速度；赫兹或Hz
10. 二进制
11. 二进制；十六进制
12. 符号位；正数；负数
13. 00000000；10000000；-127 ~ +127
14. 相同
15. 不变；按位取反
16. 补码
17. 末位加1
18. 00000000；-128 ~ +127；负
19. 减法；加法；加法器
20. $[X]_{补}$；$[-Y]_{补}$
21. 美国信息交换标准代码；西文字符
22. 4；一
23. 两
24. 一；0
25. 硬件系统；软件系统
26. 微处理器或CPU
27. 控制器；寄存器组
28. 运算器或ALU；加法器
29. 控制器或CU；分析指令或译码
30. 寄存器；缩短执行时间 或 提高运行速度
31. 主存储器或内存
32. 地址；内容
33. 外设或I/O设备；CPU或主机；I/O端口或端口
34. 输入；输出
35. 数据总线；控制总线
36. 地址；单
37. 存储器容量或内存空间；$2^{20}$ 或 1M
38. 数据；双
39. 字长
40. 控制信号；双
41. 系统；应用
42. 执行程序
43. 指令；顺序；连续
44. 取指令；分析指令或译码；执行指令

---

# 第2章 微处理器的结构和工作模式 - 填空题

**第一部分：8086 CPU的内部结构和存储器组织 (2.1)**

**2.1.1 8086 CPU内部结构及工作过程**

1.  8086 CPU 具有 ( ) 根数据总线和 ( ) 根地址总线，因此它可以并行传送 ( ) 位数据，并能寻址 ( ) 的内存空间。
2.  8086 CPU 使用其低 ( ) 位地址线来访问I/O端口，因此可访问 ( ) 个I/O端口。
3.  8088 CPU 的指令队列长度为 ( ) 字节，而8086 CPU 为 ( ) 字节；8088 的外部数据总线宽度为 ( ) 位，而8086 为 ( ) 位。
4.  8086 CPU 内部由两大单元组成：总线接口单元 (BIU) 和 ( )。
5.  BIU 的主要职责是负责CPU与 ( ) 和 ( ) 之间的数据交换。
6.  EU 的主要职责是负责 ( )。
7.  EU 内部包含进行各种算术和逻辑运算的部件，称为 ( )。
8.  8086 CPU 采用 ( ) 技术，使得取指令和执行指令可以重叠进行，从而提高程序运行速度。
9.  **当 EU 执行指令且不访问总线时，BIU 可以预取后续指令并将其存放在 ( ) 中。
10. 如果遇到 JMP 或 CALL 等转移指令，BIU会 ( ) 指令队列，并从新的地址开始取指令。

**2.1.2 8086 CPU内部寄存器**

11. 8086 CPU 的数据寄存器包括 AX、BX、CX 和 DX，它们都是 ( ) 位的寄存器。
12. 累加器是 ( ) 寄存器，在乘除法等运算中有特殊用途。
13. 基址寄存器是 ( ) 寄存器，常用于存放内存单元的偏移地址。
14. 计数寄存器是 ( ) 寄存器，在循环指令中常用作计数器。
15. 地址指针寄存器 SP 和 BP 通常与 ( ) 段寄存器配合使用，分别指向 ( ) 和访问堆栈段中的数据。
16. 源变址寄存器是 ( )，目的变址寄存器是 ( )，它们在串操作指令中有特殊用途。
17. 段寄存器 CS、DS、SS 和 ES 都是 ( ) 位的寄存器，**用于存放相应逻辑段的 ( )。
18. 代码段寄存器是 ( )，它存放的是当前正在执行的指令所在代码段的段基地址。
19. 指令指针寄存器 IP 存放的是 ( ) 要执行指令的 ( )。
20. CPU总是通过 ( ) 和 ( ) 配合来确定下一条要执行指令的物理地址。
21. 标志寄存器 FLAGS 是一个 ( ) 位的寄存器，其中包含 ( ) 个有意义的标志位。
22. 状态标志位 CF 是 ( ) 标志，当无符号数运算最高位产生进位或借位时，CF被置为 ( )。
23. 奇偶标志位是 ( )，当运算结果的低8位中包含偶数个“1”时，它被置为 ( )。
24. 辅助进位标志 AF 用于 ( ) 运算的调整。
25. 零标志位是 ( )，当运算结果为0时，它被置为 ( )。
26. 符号标志位 SF 反映运算结果的最高位，当最高位为1时，SF=1，表示结果为 ( ) (对于有符号数而言)。
27. 溢出标志位是 ( )，当有符号数运算结果超出了其表示范围时，它被置为 ( )。
28. **控制标志 TF 是 ( ) 标志，当 TF=1 时，CPU 处于 ( ) 执行模式。
29. **中断允许标志 IF 控制CPU是否响应 ( ) 中断请求。
30. 方向标志 DF 用于串操作指令，当 DF=0 时，地址指针 (如SI/DI) 的方向是 ( )。

**2.1.4 8086的存储器组织**

31. CPU与内存单元进行数据交换时实际使用的唯一地址称为 ( )，对于8086/8088 CPU，它是 ( ) 位的。
32. 在程序中使用的地址形式是逻辑地址，它由16位的 ( ) 和16位的 ( ) 组成。
33. 物理地址的计算公式为：物理地址 = ( ) × 16 + ( )。
34. 一个逻辑段的最大容量为 ( ) KB。
35. 默认情况下，取指令操作使用的逻辑地址是 ( ) : ( )。
36. **默认情况下，堆栈操作通常使用 ( ) : ( ) 或 ( ) : ( ) 来寻址。
37. 堆栈操作遵循 ( ) 的原则。
38. 执行 `PUSH AX` 指令时，堆栈指针 SP 的值会先 ( ) (操作数是16位)，然后将 AX 的内容存入 SS:SP 指向的内存单元。
39. 执行 `POP BX` 指令时，先从 SS:SP 指向的内存单元取出数据到 BX，然后堆栈指针 SP 的值会 ( )。
40. **8086 存储器在物理上分为偶地址体和奇地址体，偶地址体连接到数据总线的 ( )，由地址线 ( ) 为0时选中。
41. **奇地址体连接到数据总线的 ( )，由信号线 ( ) 为低电平时选中。
42. 当8086 CPU要访问一个起始地址为偶地址的字数据时，A0= ( ) 且 BHE= ( )，此时可以一次完成读写。
43. 8088 CPU 的外部数据总线是 ( ) 位的，因此访问一个字数据需要 ( ) 次总线操作。

**第二部分：8086的工作模式和总线操作 (2.2)**

**2.2.0 工作模式概述**

44. **8086 CPU 有两种工作模式：最小模式和最大模式，它们通过 ( ) 引脚的电平来选择。
45. 当 MN/-MX 引脚接高电平时，CPU工作在 ( ) 模式；接低电平时，工作在 ( ) 模式。
46. 最小模式适用于 ( ) 处理器系统，而最大模式适用于 ( ) 处理器系统。

**2.2.1 最小模式系统**

47. 在8086最小模式系统中，**通常使用 ( ) 芯片来提供系统所需的CLK时钟信号、READY同步信号和RESET复位信号。
48. 为了分离地址/数据复用总线上的地址信息，需要使用 ( ) 芯片，并利用CPU发出的 ( ) 信号进行控制。
49. 为了缓冲和控制数据总线的传输方向，**需要使用 ( ) 芯片，其方向由 ( ) 信号控制，使能由 ( ) 信号控制。

**2.2.2 最大模式系统**

50. **在8086最大模式系统中，CPU不再直接产生M/IO、RD、WR等控制信号，而是输出状态信号 S2、S1、S0 给外部的 ( ) 芯片，由该芯片解码产生系统总线控制信号。

**2.2.3 总线操作时序**

51. **CPU工作的最基本时间单位是 ( )，它是时钟频率的倒数。
52. **CPU通过总线完成一次对存储器或I/O端口的读/写操作所需的时间称为 ( )。
53. 一个基本的总线周期通常包含 ( ) 个时钟周期，分别称为 T1、T2、T3 和 T4。
54. 如果CPU与慢速设备通信，可以在T3和T4之间插入一个或多个 ( )，这由 ( ) 信号控制。
55. CPU执行一条指令所需的全部时间称为 ( )。
56. 在最小模式的读总线周期的T1状态，CPU输出地址，并且 ( ) 信号有效，用于锁存地址。
57. 在最小模式的读总线周期的T2状态后半周期，( ) 信号变为低电平有效，选中存储器或I/O端口。
58. 在最小模式的写总线周期的T2状态，CPU将要写的数据送到AD15-AD0总线，并且 ( ) 信号变为低电平有效。

---

**参考答案**

1.  16；20；16；1MB
2.  16；$2^{16}$ 或 64K
3.  4；6；8；16
4.  指令执行单元 (EU)
5.  内存；I/O端口
6.  执行指令
7.  算术逻辑单元 (ALU)
8.  流水线 (Pipeline)
9.  指令队列
10. 清空
11. 16
12. AX
13. BX
14. CX
15. SS (堆栈段)；栈顶
16. SI (源变址寄存器)；DI (目的变址寄存器)
17. 16；段基地址 (或段基址)
18. CS (代码段寄存器)
19. 下一条；偏移地址
20. CS (代码段寄存器)；IP (指令指针寄存器)
21. 16；9
22. 进位；1
23. PF (奇偶标志)；1
24. BCD (二进制编码的十进制数)
25. ZF (零标志)；1
26. 负数
27. OF (溢出标志)；1
28. 陷阱；单步
29. 可屏蔽 (INTR)
30. 递增
31. 物理地址；20
32. 段地址 (或段基址)；偏移地址
33. 段地址 (或段基址)；偏移地址
34. 64
35. CS；IP
36. SS；SP；SS；BP
37. 后进先出 (LIFO)
38. 减2 (SP=SP-2)
39. 加2 (SP=SP+2)
40. D7~D0；A0
41. D15~D8；BHE
42. 0；0
43. 8；两
44. MN/MX
45. 最小；最大
46. 单；多
47. 时钟发生器 (如8284A)
48. 地址锁存器 (如74LS373)；ALE (地址锁存允许)
49. 双向数据总线收发器 (如74LS245)；DT/R (数据发送/接收)；DEN (数据允许)
50. 总线控制器 (如8288)
51. 时钟周期 (或T周期/T状态)
52. 总线周期
53. 4
54. 等待周期 (Tw)；READY
55. 指令周期
56. ALE (地址锁存允许)
57. RD (读信号)
58. WR (写信号)

---

# 第3章 8086的寻址方式和指令系统 - 填空题

**3.0 指令基础**

1.  计算机的指令通常**包含 \_\_\_\_\_\_\_\_\_\_ 和 \_\_\_\_\_\_\_\_\_\_ 两部分。
2.  指令中说明操作数所在地址的方法称为 \_\_\_\_\_\_\_\_\_\_。
3.  双操作数指令中，用逗号 `,` 分隔，右边是 \_\_\_\_\_\_\_\_\_\_ 操作数，左边是 \_\_\_\_\_\_\_\_\_\_ 操作数。
4.  指令 `MOV AX, BX` 的含义是将寄存器 BX 的内容传送到寄存器 AX 中，即 $AX \leftarrow$ \_\_\_\_\_\_\_\_\_\_。

**3.1 8086的寻址方式**

5. **8086的四种主要寻址方式是：立即数寻址、\_\_\_\_\_\_\_\_\_\_ 寻址、存储器寻址和 \_\_\_\_\_\_\_\_\_\_ 寻址。
6.  \_\_\_\_\_\_\_\_\_\_ 寻址方式的操作数直接在指令中给出，作为指令的一部分。
7.  \_\_\_\_\_\_\_\_\_\_ 寻址方式的操作数存放在CPU内部的寄存器中，执行速度最快。
8.  存储器寻址方式中，操作数存放在存储器中，指令提供计算操作数 \_\_\_\_\_\_\_\_\_\_ 的信息。

**3.1.1 立即寻址方式**

9.  立即数是一个8位或16位的 \_\_\_\_\_\_\_\_\_\_，直接包含在指令代码中。
10. 立即数只能作 \_\_\_\_\_\_\_\_\_\_ 操作数，不能作 \_\_\_\_\_\_\_\_\_\_ 操作数。
11. 如果16进制立即数以字母A~F开头，前面必须加数字 \_\_\_\_\_\_\_\_\_\_，以区分符号地址。

**3.1.2 寄存器寻址方式**

12. 寄存器寻址时，源操作数和目的操作数的 \_\_\_\_\_\_\_\_\_\_ 必须一致。
13. 指令 `MOV CX, AH` 是错误的，因为 \_\_\_\_\_\_\_\_\_\_。

**3.1.3 存储器寻址方式**

14. 存储器寻址中，操作数在内存中，指令用不同方法给出存储单元的 \_\_\_\_\_\_\_\_\_\_ 地址，即偏移地址。
15. 8086的物理地址计算公式为：$PA = \text{段基址} \times 16 +$ \_\_\_\_\_\_\_\_\_\_。
16. 直接寻址方式中，操作数的有效地址EA直接在 \_\_\_\_\_\_\_\_\_\_ 中以数值形式给出。
17. 直接寻址方式中，数据默认存放在 \_\_\_\_\_\_\_\_\_\_ 段，段地址由 \_\_\_\_\_\_\_\_\_\_ 寄存器提供。
18. 指令 `MOV AX, ES:[500H]` 使用了 \_\_\_\_\_\_\_\_\_\_ 前缀，从 \_\_\_\_\_\_\_\_\_\_ 段获取数据。
19. **寄存器间接寻址方式中，操作数的有效地址EA存放在间接寻址寄存器 \_\_\_\_\_\_\_\_\_\_、\_\_\_\_\_\_\_\_\_\_、\_\_\_\_\_\_\_\_\_\_ 或 \_\_\_\_\_\_\_\_\_\_ 中。
20. **寄存器间接寻址中，如果使用 `BP`，则默认段寄存器是 \_\_\_\_\_\_\_\_\_\_。
21. 寄存器相对寻址方式的有效地址EA是间接寻址寄存器的内容与一个8位或16位 \_\_\_\_\_\_\_\_\_\_ 之和。
22. 基址变址寻址方式的有效地址EA是一个 \_\_\_\_\_\_\_\_\_\_ 寄存器（`BX`或`BP`）的内容与一个 \_\_\_\_\_\_\_\_\_\_ 寄存器（`SI`或`DI`）的内容之和。
23. 基址变址寻址中，若基址寄存器是 `BP`，则默认段寄存器是 \_\_\_\_\_\_\_\_\_\_。
24. 相对基址变址寻址的EA是基址寄存器内容、变址寄存器内容以及一个8位或16位 \_\_\_\_\_\_\_\_\_\_ 三者之和。
25. 存储器间接寻址规则中，方括号 `[]` 内不能同时出现 `BX` 和 \_\_\_\_\_\_\_\_\_\_，也不能同时出现 `SI` 和 \_\_\_\_\_\_\_\_\_\_。
26. 存储器间接寻址规则中，如果 `[]` 内包含 `BP`，则默认段是 \_\_\_\_\_\_\_\_\_\_；其他情况默认段是 \_\_\_\_\_\_\_\_\_\_。

**3.1.4 I/O 端口寻址方式**

27. 直接端口寻址的端口地址是一个 \_\_\_\_\_\_\_\_\_\_ 位的立即数，范围是 \_\_\_\_\_\_\_\_\_\_ 到 \_\_\_\_\_\_\_\_\_\_。
28. **间接端口寻址的端口地址是16位的，该地址预先存放在 \_\_\_\_\_\_\_\_\_\_ 寄存器中。

**3.3.1 数据传送指令**
 
29. `MOV 目的, 源` 指令中，`CS` 寄存器不能作为 \_\_\_\_\_\_\_\_\_\_ 操作数。
30. `MOV` 指令中，源操作数和目的操作数不能同时为 \_\_\_\_\_\_\_\_\_\_ 。
31. 段寄存器（如`DS`）不能直接用 \_\_\_\_\_\_\_\_\_\_ 赋值，通常需要通过通用寄存器中转。
32. `PUSH 源` 指令的操作是先使 $SP \leftarrow SP - 2$，然后将源操作数（16位）存入 \_\_\_\_\_\_\_\_\_\_ 指向的堆栈顶部。
33. `PUSH` 指令的源操作数不能是 \_\_\_\_\_\_\_\_\_\_。
34. `POP 目的` 指令的目的操作数不能是 \_\_\_\_\_\_\_\_\_\_ 寄存器。
35. `XCHG 目的, 源` 指令不能直接交换两个 \_\_\_\_\_\_\_\_\_\_ 的内容。
36. `XLAT` 指令查表时，`BX` 包含转换表的 \_\_\_\_\_\_\_\_\_\_，`AL` 包含要转换的值作为查表 \_\_\_\_\_\_\_\_\_\_。
37. `IN AL, DX` 指令中，当端口地址大于 `FFH` 时，必须先将端口地址放入 \_\_\_\_\_\_\_\_\_\_ 寄存器。
38. `LEA 目的, 源` 指令将源操作数（存储单元）的 \_\_\_\_\_\_\_\_\_\_ 送到目的寄存器。
39. `LDS 目的, 源` 指令从源地址加载一个32位数，其中低16位送 \_\_\_\_\_\_\_\_\_\_，高16位送 \_\_\_\_\_\_\_\_\_\_ 寄存器。
40. `LAHF` 指令将标志寄存器`FLAGS`的 \_\_\_\_\_\_\_\_\_\_（高8位/低8位）传送到`AH`寄存器。
41. `POPF` 指令从堆栈顶部弹出一个字到 \_\_\_\_\_\_\_\_\_\_ 寄存器。

**3.3.2 算术运算指令**

42. `ADC 目的, 源` 指令的功能是：目的 $\leftarrow$ 目的 + 源 + \_\_\_\_\_\_\_\_\_\_。
43. **`INC 目的` 指令执行后 \_\_\_\_\_\_\_\_\_\_ (影响/不影响) `CF` 标志位。
44. `AAA` 指令用于对`AL`中两个 \_\_\_\_\_\_\_\_\_\_ BCD数或ASCII数加法后的结果进行调整。
45. `DAA` 指令用于对`AL`中两个 \_\_\_\_\_\_\_\_\_\_ BCD数加法后的结果进行调整。
46. `NEG 目的` 指令的功能是求目的操作数的 \_\_\_\_\_\_\_\_\_\_（用0减去目的操作数）。
47. `CMP 目的, 源` 指令计算 `目的 - 源`，仅根据结果设置 \_\_\_\_\_\_\_\_\_\_，不保存结果。
48. 无符号数乘法指令 `MUL 源`，若源为字节，则结果存放在 \_\_\_\_\_\_\_\_\_\_ 寄存器；若源为字，则结果存放在 \_\_\_\_\_\_\_\_\_\_ : \_\_\_\_\_\_\_\_\_\_ 寄存器对。
49. **带符号数乘法指令 `IMUL 源`，如果结果的高半部分不是低半部分的符号扩展，则 `CF` 和 `OF` 标志位均置 \_\_\_\_\_\_\_\_\_\_。
50. `AAM` 指令将`AL`中的二进制乘积调整为两个非压缩BCD数，其中十位存入 \_\_\_\_\_\_\_\_\_\_，个位存入 \_\_\_\_\_\_\_\_\_\_。
51. 无符号数除法指令 `DIV 源`，若源为字节，则商在 \_\_\_\_\_\_\_\_\_\_，余数在 \_\_\_\_\_\_\_\_\_\_。
52. `IDIV` 进行带符号字节除法前，若被除数在`AL`，应使用 \_\_\_\_\_\_\_\_\_\_ 指令将其符号扩展到`AH`。
53. `CWD` 指令将 \_\_\_\_\_\_\_\_\_\_ 寄存器中的字按符号位扩展到 \_\_\_\_\_\_\_\_\_\_ 寄存器。
54. **`AAD` 指令在除法 \_\_\_\_\_\_\_\_\_\_ (之前/之后) 使用，将`AX`中两个非压缩BCD数调整为一个二进制数存入`AL`。

**3.3.3 逻辑运算和移位指令**

55. **`AND 目的, 源` 指令执行后，`CF` 和 `OF` 标志位总是为 \_\_\_\_\_\_\_\_\_\_。
56. `XOR AX, AX` 指令常用于将 `AX` 寄存器的内容 \_\_\_\_\_\_\_\_\_\_。
57. `TEST 目的, 源` 指令计算 `目的 \land 源`，仅设置标志位，\_\_\_\_\_\_\_\_\_\_ (保存/不保存) 结果。
58. `SAL` / `SHL` 指令中，最高位 (MSB) 移入 \_\_\_\_\_\_\_\_\_\_，最低位 (LSB) 补 \_\_\_\_\_\_\_\_\_\_。
59. 算术右移指令 `SAR` 中，最高位 (MSB) \_\_\_\_\_\_\_\_\_\_ (补0/补1/保持不变)。
60. 循环左移指令 `ROL` 中，最高位 (MSB) 移入 `CF` 并且移到 \_\_\_\_\_\_\_\_\_\_。
61. 带进位循环左移指令 `RCL` 中，`CF` 移入 \_\_\_\_\_\_\_\_\_\_，MSB 移入 \_\_\_\_\_\_\_\_\_\_。

**3.3.4 字符串处理指令**

62. 字符串指令中，源串地址隐含使用 \_\_\_\_\_\_\_\_\_\_ : \_\_\_\_\_\_\_\_\_\_ 寄存器对。
63. 字符串指令中，目的串地址隐含使用 \_\_\_\_\_\_\_\_\_\_ : \_\_\_\_\_\_\_\_\_\_ 寄存器对。
64. 字符串操作时，地址的增减由 \_\_\_\_\_\_\_\_\_\_ 标志位控制。
65. **当 `DF=0` 时，每次字符串操作后 `SI` 和 `DI` \_\_\_\_\_\_\_\_\_\_ (递增/递减)。
66. 字符串操作的重复次数通常由 \_\_\_\_\_\_\_\_\_\_ 寄存器指定。
67. 重复前缀 `REPE` / `REPZ` 表示当 \_\_\_\_\_\_\_\_\_\_ = 1 且 `CX`≠0 时重复执行。
68. `MOVSB` 指令将 `[DS:SI]` 指向的 \_\_\_\_\_\_\_\_\_\_ (字节/字) 传送到 `[ES:DI]`，然后更新`SI`, `DI`。
69. **`SCASW` 指令将 \_\_\_\_\_\_\_\_\_\_ 寄存器的内容与 `[ES:DI]` 指向的字进行比较，然后更新`DI`。
70. `STOSB` 指令将 \_\_\_\_\_\_\_\_\_\_ 寄存器的内容存入 `[ES:DI]` 指向的字节单元，然后更新`DI`。

**3.3.5 控制转移指令**

71. `JMP` 指令的段内短转移，其目标地址的偏移量为 \_\_\_\_\_\_\_\_\_\_ 位。
72. `JMP FAR PTR label` 是一条段间 \_\_\_\_\_\_\_\_\_\_ (直接/间接) 转移指令。
73. **`CALL` 指令进行段内调用时，压入堆栈的是 \_\_\_\_\_\_\_\_\_\_ 寄存器的内容。
74. `CALL` 指令进行段间调用时，依次压入堆栈的是 \_\_\_\_\_\_\_\_\_\_ 和 \_\_\_\_\_\_\_\_\_\_ 寄存器的内容。
75. `RET n` 指令从子程序返回，并在弹出返回地址后，再将 `SP` 的内容增加 \_\_\_\_\_\_\_\_\_\_。
76. 所有的条件转移指令都是段内 \_\_\_\_\_\_\_\_\_\_ (短/近/远) 转移。
77. 条件转移指令 `JA label` (无符号数大于则跳转) 的条件是 `CF`= \_\_\_\_\_ 且 `ZF`= \_\_\_\_\_。
78. 条件转移指令 `JL label` (带符号数小于则跳转) 的条件是 `SF` \_\_\_\_\_ (等于/不等于) `OF`。
79. `LOOP 标号` 指令的操作是先将 `CX` 减1，若 `CX` \_\_\_\_\_\_\_\_\_\_ 0，则跳转到标号。
80. `JCXZ 标号` 指令在跳转前 \_\_\_\_\_\_\_\_\_\_ (会/不会) 修改 `CX` 的值。
81. `INT n` 指令执行时，处理器会将标志寄存器压栈，并自动将 `TF` 和 `IF` 标志位 \_\_\_\_\_\_\_\_\_\_ (置1/清0)。
82. **`INTO` 指令在溢出标志位 `OF` = 1 时，产生类型号为 \_\_\_\_\_\_\_\_\_\_ 的中断。
83. **`IRET` 指令从中断服务程序返回时，依次从堆栈弹出 \_\_\_\_\_\_\_\_\_\_、\_\_\_\_\_\_\_\_\_\_ 和 \_\_\_\_\_\_\_\_\_\_。

**3.3.6 处理器控制指令**

84. `CLC` 指令使进位标志 `CF` $\leftarrow$ \_\_\_\_\_\_\_\_\_\_。
85. `STD` 指令使方向标志 `DF` $\leftarrow$ \_\_\_\_\_\_\_\_\_\_，用于字符串操作地址 \_\_\_\_\_\_\_\_\_\_ (递增/递减)。
86. `CLI` 指令使中断允许标志 `IF` $\leftarrow$ \_\_\_\_\_\_\_\_\_\_，用于 \_\_\_\_\_\_\_\_\_\_ (允许/禁止) 可屏蔽中断。
87. `NOP` 指令是一条 \_\_\_\_\_\_\_\_\_\_ 操作指令，占用时钟周期但不执行任何操作。

---

**答案区

1.  操作码, 操作数
2.  寻址方式
3.  源, 目的
4.  BX
5.  寄存器, I/O端口
6.  立即数
7.  寄存器
8.  有效地址 (EA)
9.  常数
10. 源, 目的
11. 0
12. 长度 (位数)
13. 源操作数(AH, 8位)和目的操作数(CX, 16位)长度不一致
14. 有效地址 (EA)
15. 有效地址 (EA)
16. 方括号`[]`
17. 数据段 (Data Segment), DS
18. 段超越, 附加段 (Extra Segment)
19. BX, BP, SI, DI
20. SS (堆栈段)
21. 位移量 (Displacement)
22. 基址, 变址
23. SS (堆栈段)
24. 位移量 (Displacement)
25. BP, DI
26. SS, DS
27. 8, 00H, FFH
28. DX
29. 目的
30. 存储
31. 立即数
32. SS:SP
33. 立即数
34. CS
35. 存储单元
36. 基地址, 位移量
37. DX
38. 偏移地址 (OFFSET)
39. 目的寄存器, DS
40. 低8位
41. FLAGS
42. CF (进位标志)
43. 不影响
44. 非压缩
45. 压缩
46. 补码
47. 标志位
48. AX, DX, AX
49. 1
50. AH, AL
51. AL, AH
52. CBW
53. AX, DX
54. 之前
55. 0
56. 清零
57. 不保存
58. CF, 0
59. 保持不变
60. 最低位 (LSB)
61. LSB, CF
62. DS, SI
63. ES, DI
64. DF (方向标志)
65. 递增
66. CX
67. ZF (零标志)
68. 字节
69. AX
70. AL
71. 8
72. 直接
73. IP
74. CS, IP
75. n
76. 短
77. 0, 0
78. 不等于 (≠)
79. ≠ (不等于)
80. 不会
81. 清0
82. 4
83. IP, CS, FLAGS
84. 0
85. 1, 递减
86. 0, 禁止
87. 空

---

# 第4章 汇编程序设计 - 填空题

**4.1 完整的汇编语言源程序框架**

1.  一个典型的汇编语言源程序通常至少包含数据段、\_\_\_\_\_\_\_\_\_\_ 段和代码段。
2.  数据段使用 `DATA SEGMENT` 开始，并以 `DATA` \_\_\_\_\_\_\_\_\_\_ 结束。
3.  **定义100字节的堆栈空间，初始值未知的语句是：`DB 100` \_\_\_\_\_\_\_\_\_\_ `(?)`。
4.  **`ASSUME` 语句的作用是告诉汇编器逻辑段与 \_\_\_\_\_\_\_\_\_\_ 的约定关系。
5.  在代码段开始处，通常需要通过 `MOV AX, DATA` 和 `MOV` \_\_\_\_\_\_\_\_\_\_ `, AX` 来初始化数据段寄存器。
6.  **程序的入口点标号（如 `START`）需要在 \_\_\_\_\_\_\_\_\_\_ 语句中指明。
7.  程序正常结束返回DOS的标准方式是使用 `INT 21H` 的 \_\_\_\_\_\_\_\_ 功能调用。
8.  当主程序定义为一个 `FAR` 过程时，可以通过 \_\_\_\_\_\_\_\_\_\_ 指令返回DOS。
9.  **操作系统加载 `.EXE` 文件时，会在程序加载前建立一个256字节的 \_\_\_\_\_\_\_\_\_\_，简称PSP。
10. 程序启动时，`DS` 和 `ES` 寄存器被操作系统初始化为指向 \_\_\_\_\_\_\_\_\_\_ 的起始地址。
11. `CS:IP` 的初始值由加载程序根据 `END` 语句指定的 \_\_\_\_\_\_\_\_\_\_ 设置。

**程序示例填空 (源程序框架)**

```assembly
STACK SEGMENT PARA STACK 'STACK'
    DB 50 DUP(?) ; 定义50字节的堆栈空间
STACK ENDS

DATA SEGMENT
    MSG DB 'Hello World!', 0DH, 0AH, '$'
    VAR1 DW ?
DATA ENDS

CODE SEGMENT
    ASSUME CS:CODE, DS:______, SS:______

MAIN_PROG:
    MOV AX, DATA
    MOV ______, AX

    ; 显示MSG字符串
    MOV DX, OFFSET MSG
    MOV AH, ______      ; 使用DOS功能号显示字符串
    INT 21H

    ; 程序结束
    MOV AH, 4CH
    INT ______

CODE ENDS
END ______
```
12. 上述程序中 `ASSUME` 语句应填写：`DS:______` (逻辑段名) 和 `SS:______` (逻辑段名)。
13. 上述程序中初始化 `DS` 的下一句 `MOV ______, AX` 应填写段寄存器名。
14. 上述程序中显示字符串的功能号应填入 `AH` 的是 \_\_\_\_\_\_\_\_\_\_。
15. 上述程序中结束程序的 `INT` 指令应填写中断号 \_\_\_\_\_\_\_\_\_\_。
16. 上述程序中 `END` 语句后应指定程序入口点 \_\_\_\_\_\_\_\_\_\_。

**4.2 DOS系统功能调用**

17. 调用DOS系统功能，通常先将子功能号放入 \_\_\_\_\_\_\_\_\_\_ 寄存器。
18. `INT 21H` 的 `01H` 功能用于键盘输入单个字符，输入的字符ASCII码存放在 \_\_\_\_\_\_\_\_\_\_ 寄存器。
19. `INT 21H` 的 `02H` 功能用于屏幕输出单个字符，要输出字符的ASCII码需放入 \_\_\_\_\_\_\_\_\_\_ 寄存器。
20. 使用 `INT 21H` 的 `09H` 功能输出字符串时，字符串必须以 \_\_\_\_\_\_\_\_\_\_ 符号作为结束标志。
21. `INT 21H` 的 `09H` 功能要求 `DS:DX` 指向要输出字符串的 \_\_\_\_\_\_\_\_\_\_。
22. **`INT 21H` 的 `0AH` 功能用于键盘输入字符串，输入缓冲区的第一个字节存放的是缓冲区的 \_\_\_\_\_\_\_\_\_\_。
23. **`INT 21H` 的 `0AH` 功能中，输入缓冲区第二个字节由DOS填充，表示 \_\_\_\_\_\_\_\_\_\_。
24. 使用 `INT 21H` 的 `4CH` 功能终止程序时，`AL` 寄存器中存放的是 \_\_\_\_\_\_\_\_\_\_。

**程序示例填空 (DOS调用)**

```assembly
; 示例1: 显示星号 '*'
MOV ______, '*'   ; 将要显示字符 '*' 的 ASCII 码放入DL寄存器
	MOV AH, ______   ; 将功能号 (显示字符) 放入AH寄存器
INT 21H
```
25. 上述显示星号的程序中，第一个空应填 \_\_\_\_\_\_\_\_\_\_，第二个空应填 \_\_\_\_\_\_\_\_\_\_。

```assembly
; 示例2: 显示 "Try again." 并回车换行
DATA SEGMENT
    MESS DB 'Try again.', ______, ______, '$'
DATA ENDS
; ...
CODE SEGMENT
START:
    MOV AX, DATA
    MOV DS, AX
    MOV DX, ______ MESS ; 将字符串MESS的偏移地址放入DX
    MOV AH, 09H
    INT 21H
CODE ENDS
END START
```
26. 上述显示 "Try again." 的字符串定义中，回车符和换行符的十六进制ASCII码分别是 \_\_\_\_\_\_\_\_\_\_ 和 \_\_\_\_\_\_\_\_\_\_。
27. 上述显示 "Try again." 的代码中，获取 `MESS` 偏移地址的操作符是 \_\_\_\_\_\_\_\_\_\_。

**4.3 汇编程序的上机处理过程**

28. 汇编语言源程序的文件扩展名通常是 \_\_\_\_\_\_\_\_\_\_。
29. 使用汇编器（如 `MASM`）将 `.ASM` 文件翻译成机器语言的 \_\_\_\_\_\_\_\_\_\_ 文件。
30. 链接器（如 `LINK`）将 `.OBJ` 文件和库文件组合生成可执行的 \_\_\_\_\_\_\_\_\_\_ 文件。
	.asm -> .obj -> .exe

**4.4 常用知识点 (伪指令和操作符)**

31. 指示汇编器如何工作的指令，不直接翻译成机器码的称为 \_\_\_\_\_\_\_\_\_\_ 指令。
32. `DB` 用于定义 \_\_\_\_\_\_\_\_\_\_ 类型数据，`DW` 用于定义 \_\_\_\_\_\_\_\_\_\_ 类型数据。
33. `DB 10 DUP(0)` 定义了10个字节，每个字节的初始值都是 \_\_\_\_\_\_\_\_\_\_。
34. 伪指令 `EQU` 用于定义 \_\_\_\_\_\_\_\_\_\_，它 \_\_\_\_\_\_\_\_\_\_ (分配/不分配) 存储空间。
35. 在数据定义中，符号 `$` 代表当前指令或数据所在的 \_\_\_\_\_\_\_\_\_\_ 地址。
36. `VAR1 DB 1,2,3` 后，`LEN EQU $-VAR1`，则 `LEN` 的值是 \_\_\_\_\_\_\_\_\_\_。
37. 在 `DB`, `DW` 定义中，`?` 表示该数据项的值是 \_\_\_\_\_\_\_\_\_\_。
38. **变量的三个属性是：段地址、偏移地址和 \_\_\_\_\_\_\_\_\_\_。
39. `OFFSET VAR1` 操作符获取 `VAR1` 的 \_\_\_\_\_\_\_\_\_\_。
40. `SEG VAR1` 操作符获取 `VAR1` 所在段的 \_\_\_\_\_\_\_\_\_\_。
41. 如果 `VAR1 DW ?`，则 `TYPE VAR1` 返回的值是 \_\_\_\_\_\_\_\_\_\_。
42. 如果 `BUFFER DB 50 DUP(?)`，则 `LENGTH BUFFER` 返回的值是 \_\_\_\_\_\_\_\_\_\_。
43. **如果 `BUFFER DW 10 DUP(0)`，则 `SIZE BUFFER` 返回的值是 \_\_\_\_\_\_\_\_\_\_ (字节数)。
44. **`PTR` (Pointer)操作符用于临时 \_\_\_\_\_\_\_\_\_\_ 内存操作数的类型属性。
45. 若 `SUM DW 1234H`，则 `MOV AL, BYTE PTR SUM` 后，`AL` 的内容是 \_\_\_\_\_\_\_\_\_\_。

**4.5 分支结构编程**

46. 实现分支结构通常使用 \_\_\_\_\_\_\_\_\_\_ 指令和条件跳转指令。
47. 指令 `CMP AL, BL` 后，如果 `AL = BL`，则零标志位 `ZF` 被置为 \_\_\_\_\_\_\_\_\_\_。
48. `JE LP1` 指令表示如果相等则跳转到标号 \_\_\_\_\_\_\_\_\_\_。
49. 习题1中，若 `AL` 中的十六进制数大于9，则跳转到 `LP1` 使用的指令是 `JA LP1`，其中 `JA` 表示无符号 \_\_\_\_\_\_\_\_\_\_ 则跳转。
50. 习题1中，将0-9的数字转换为ASCII码，是将其加上 \_\_\_\_\_\_\_\_\_\_H。
51. 习题2中，判断字符是否小于'A'使用的指令是 `CMP AL, 'A'` 后跟 `JB EXIT`，其中 `JB` 表示无符号 \_\_\_\_\_\_\_\_\_\_ 则跳转。
52. 大写字母转换为对应小写字母，其ASCII码需要加上 \_\_\_\_\_\_\_\_\_\_H。
53. 习题3中，比较变量X与0，判断X是否大于0，使用的是带符号比较后的 \_\_\_\_\_\_\_\_\_\_  指令。
54. 习题4中，统计字节数组 `buffer` 中负数的个数，循环控制使用的指令是 `LOOP LP`，它会使 `CX` 减1并判断是否为 \_\_\_\_\_\_\_\_\_\_。
55. 若习题4中 `buffer` 数组类型改为 `DW`，则比较指令应为 `CMP WORD PTR buffer[SI], 0`，并且索引 `SI` 每次应增加 \_\_\_\_\_\_\_\_\_\_。

**程序示例填空 (分支结构 - 习题1)**

```assembly
; AL 存放一个十六进制数 (0-F)
    CMP AL, ______      ;
    JA  LP1
    ADD AL, 30H
    JMP ______
LP1: ADD AL, ______     ; 
EXIT:
```
56. 上述代码中，`CMP AL, ______` 应填入数字 \_\_\_\_\_\_\_\_\_\_。
57. 上述代码中，`JMP ______` 应填入跳转目标标号 \_\_\_\_\_\_\_\_\_\_。
58. 上述代码中，`LP1` 处处理A-F时，`AL` 应加上 \_\_\_\_\_\_\_\_\_\_H。

**4.6 子程序设计**

59. 子程序（过程）定义的伪指令是 `PROC` 和 \_\_\_\_\_\_\_\_\_\_。
60. 中断服务程序必须使用 \_\_\_\_\_\_\_\_\_\_ 指令返回。
61. 调用子程序的指令是 \_\_\_\_\_\_\_\_\_\_。
62. 在子程序开始时，使用 `PUSH` 指令保护现场；在子程序结束 (`RET` 之前)，使用 `POP` 指令按 \_\_\_\_\_\_\_\_\_\_ 顺序恢复现场。
63. 主调程序向子程序传递少量参数最简单高效的方式是使用 \_\_\_\_\_\_\_\_\_\_ 传递。
64. 子程序 `SUM PROC NEAR` 中，累加字节数组元素到 `AX` 时，使用 `ADD AL, [SI]` 后，通常跟一条 `ADC AH, ______` 指令来处理超过255的进位。

**程序示例填空 (子程序 - 现场保护)**

```assembly
MySub PROC NEAR
    PUSH AX
    PUSH ______  ; 假设还要保护 BX
    ; ... 子程序体 ...
    POP BX
    POP ______
    RET
MySub ENDP
```
65. 上述子程序现场保护中，第二个 `PUSH` 指令应为 `PUSH ______`。
66. 上述子程序现场恢复中，第二个 `POP` 指令应为 `POP ______`。

---

**答案区 (请独立完成后对照)**

1.  堆栈段
2.  ENDS
3.  DUP
4.  段寄存器
5.  DS
6.  END
7.  4CH
8.  RET
9.  程序段前缀区 (PSP)
10. PSP (程序段前缀区)
11. 入口点标号 (的偏移地址)
12. DATA, STACK
13. DS
14. 09H
15. 21H
16. MAIN_PROG
17. AH
18. AL
19. DL
20. '$' (美元符号)
21. 首地址 (或 内存地址)
22. 最大容量 (MaxLen)
23. 实际读入的字符数 (ActualLen)
24. 返回码 (Exit Code)
25. DL, 02H
26. 0DH, 0AH
27. OFFSET
28. .ASM
29. 目标 (.OBJ)
30. .EXE
31. 伪 (Pseudo)
32. 字节 (Byte), 字 (Word)
33. 0
34. 符号常量, 不分配
35. 偏移
36. 3
37. 未知 (或 未初始化)
38. 类型
39. 偏移地址
40. 段地址
41. 2
42. 50
43. 20 (10 * 2)
44. 修改 (或 改变)
45. 34H
46. 比较 (如 CMP)
47. 1
48. LP1
49. 大于
50. 30
51. 小于
52. 20
53. JG (或 JGE, JL, JE 组合判断)
54. 0
55. 2
56. 9
57. EXIT
58. 37
59. ENDP
60. IRET
61. CALL
62. 相反
63. 寄存器
64. 0
65. BX
66. AX
---
# 第5章 半导体存储器 - 填空题

1.  计算机中用来存储程序和数据的部件称为 \_\_\_\_\_\_\_\_\_\_。
2.  存储器层次结构中，越靠近CPU的存储器速度越快，但容量通常越 \_\_\_\_\_\_\_\_\_\_，成本越 \_\_\_\_\_\_\_\_\_\_。
3.  能够长期保存信息，断电不丢失的存储器称为 \_\_\_\_\_\_\_\_\_\_，例如硬盘。
4.  通常指主板上的内存条，用于存放当前正在执行的数据和程序的存储器称为 \_\_\_\_\_\_\_\_\_\_ (或主存)，它一般是 \_\_\_\_\_\_\_\_\_\_ (易失/非易失) 的。
5.  外存的访问时间通常是 \_\_\_\_\_\_\_\_\_\_ 级，而内存的访问时间通常是 \_\_\_\_\_\_\_\_\_\_ 级。
6.  半导体存储器按数据保存特性和读写过程可分为 RAM 和 \_\_\_\_\_\_\_\_\_\_ 两大类。
7.  SRAM 是 \_\_\_\_\_\_\_\_\_\_ RAM 的缩写，其存储单元基于 \_\_\_\_\_\_\_\_\_\_。
8.  DRAM 是 \_\_\_\_\_\_\_\_\_\_ RAM 的缩写，其存储单元基于 \_\_\_\_\_\_\_\_\_\_。
9.  EPROM 是指 \_\_\_\_\_\_\_\_\_\_ 可擦除可编程只读存储器。
10. Flash Memory (快擦写存储器) 是一种可以用电信号擦除和写入，通常按 \_\_\_\_\_\_\_\_\_\_ 擦除的存储器。
11. RAM 的特点是存储单元内容可读可写，断电后信息丢失，具有 \_\_\_\_\_\_\_\_\_\_ 性。
12. SRAM 读写速度快，\_\_\_\_\_\_\_\_\_\_ (需要/不需要) 刷新，主要用于高速缓冲存储器 (Cache)。
13. DRAM 集成度高，成本低，但需要定期 \_\_\_\_\_\_\_\_\_\_ 以保持信息，主要用作计算机的主存储器。
14. ROM 的特点是正常工作时信息只能读出，断电后信息不丢失，具有 \_\_\_\_\_\_\_\_\_\_ 性。
15. 在生产制造时直接写入内容，用户无法修改的ROM称为 \_\_\_\_\_\_\_\_\_\_ ROM。
16. 可以用紫外线照射擦除窗口，清除全部内容后重新编程的ROM是 \_\_\_\_\_\_\_\_\_\_。

**表格知识点填空**

| 类型 | 组成单元       | 速度 | 集成度 | 刷新 | 应用         |
| :--- | :------------- | :--- | :----- | :--- | :----------- |
| SRAM | (17)\_\_\_\_\_ | 快   | 低     | (18)\_\_\_\_\_ | Cache        |
| DRAM | 栅极电容 + MOS | 慢   | 高     | (19)\_\_\_\_\_ | (20)\_\_\_\_\_ |

17. 表格中 SRAM 的组成单元是 \_\_\_\_\_\_\_\_\_\_。
18. 表格中 SRAM 的刷新需求是 \_\_\_\_\_\_\_\_\_\_。
19. 表格中 DRAM 的刷新需求是 \_\_\_\_\_\_\_\_\_\_。
20. 表格中 DRAM 的主要应用是 \_\_\_\_\_\_\_\_\_\_。

**2. 半导体存储器的主要指标**

21. 一块存储器芯片所能存储的二进制位数称为存储 \_\_\_\_\_\_\_\_\_\_。
22. 存储器容量的计算公式是：存储单元数 × \_\_\_\_\_\_\_\_\_\_。
23. **存储器的存储单元数由 \_\_\_\_\_\_\_\_\_\_ 线的数量决定，若有n根，则有 $2^n$ 个单元。
24. 每单元数据位数（字长）由 \_\_\_\_\_\_\_\_\_\_ 线的数量决定。
25. 一个芯片有10根地址线，4根数据线，其容量表示为 $1K \times$ \_\_\_\_\_\_\_\_\_\_ 位。
26. 存取时间是指从CPU给出有效地址开始，到存储器稳定输出有效数据所需的 \_\_\_\_\_\_\_\_\_\_。

**3. 存储芯片的介绍**

27. 存储芯片内部由大量基本存储单元按矩阵排列组成，用于存储数据的部分称为 \_\_\_\_\_\_\_\_\_\_。
28. 将输入的地址信号转换为选中特定存储单元信号的电路是 \_\_\_\_\_\_\_\_\_\_。
29. 连接芯片内部数据线和外部数据总线，具有高阻态功能的电路是 \_\_\_\_\_\_\_\_\_\_ 缓冲器。
30. Intel 6116 芯片是一款 2K×8位的静态RAM，它有 \_\_\_\_\_\_\_\_\_\_ 根地址线。
31. 存储芯片的 $\overline{CS}$ 引脚是 \_\_\_\_\_\_\_\_\_\_ 信号，低电平有效。
32. 存储芯片的 $\overline{WE}$ 引脚是 \_\_\_\_\_\_\_\_\_\_ 使能信号，低电平有效。
33. 存储芯片进行读操作时，$\overline{CS}$ 应为0，$\overline{OE}$ 应为0，$\overline{WE}$ 应为 \_\_\_\_\_\_\_\_\_\_。
34. 当存储芯片的 $\overline{CS}=1$ 时，其数据线呈 \_\_\_\_\_\_\_\_\_\_ 状态。

**4. 存储器的连接与扩充**

35. CPU与存储器连接的核心是CPU的系统总线与存储芯片对应引脚的连接，关键在于存储芯片地址分配和 \_\_\_\_\_\_\_\_\_\_ 信号的产生。
36. CPU地址总线中的低位地址线连接到存储芯片的地址输入端，用于选择芯片 \_\_\_\_\_\_\_\_\_\_ 的存储单元。
37. CPU地址总线中的高位地址线用于 \_\_\_\_\_\_\_\_\_\_，产生片选信号，用于选择不同的存储芯片。
38. CPU的读信号 ($\overline{RD}$) 通常连接到存储芯片的输出使能 \_\_\_\_\_\_\_\_\_\_ 引脚。
39. 增加存储器系统的数据位数（字长）的扩充方法称为 \_\_\_\_\_\_\_\_\_\_ 扩充。
40. 位数扩充时，所有芯片的地址线和片选线通常 \_\_\_\_\_\_\_\_\_\_ (并联/分别连接)。
41. 用2片1K×4位的RAM芯片组成1K×8位的存储系统，一片芯片的数据线接CPU的D0-D3，另一片接CPU的 \_\_\_\_\_\_\_\_\_\_。
42. 增加存储器系统的存储单元数量（地址空间）的扩充方法称为 \_\_\_\_\_\_\_\_\_\_ 扩充。
43. 字数扩充时，所有芯片的数据线通常 \_\_\_\_\_\_\_\_\_\_ (并联/分组连接)。
44. 字数扩充时，各芯片的片选线由CPU的 \_\_\_\_\_\_\_\_\_\_ 地址线经译码产生。
45. 用4片2K×8的EPROM芯片组成8K×8的存储系统，CPU需要13根地址线寻址8K，其中A0-A10接所有芯片的片内地址线，而A11和A12通过 \_\_\_\_\_\_\_\_\_\_ 产生4个独立的片选信号。
46. 当芯片的位数和字数都不满足要求时，需要进行 \_\_\_\_\_\_\_\_\_\_ 扩充。
47. **全译码法中，所有未被芯片内部使用的CPU高位地址线都参与译码，其优点是每个芯片的地址范围 \_\_\_\_\_\_\_\_\_\_。
48. **部分译码法只用部分高位地址线参与译码，其缺点是会导致 \_\_\_\_\_\_\_\_\_\_ (Aliasing)。
49. **线选法是高位地址线不经过译码器，直接连接到存储芯片的片选端，其优点是电路 \_\_\_\_\_\_\_\_\_\_。
50. 74LS138是一款3线-8线译码器，当其使能端满足条件（如 $G1=1, \overline{G2A}=0, \overline{G2B}=0$）时，根据3个输入地址线的状态，在8个输出端中选择一个输出 \_\_\_\_\_\_\_\_\_\_ 电平。

**程序/连接示例相关填空**

51. 在P14用2716组成8K×8存储器的示例中，CPU的A0-A10地址线连接到所有2716芯片的 \_\_\_\_\_\_\_\_\_\_ 引脚。
52. 在P21-22用6116组成8KB RAM的全译码法示例中，若片1的地址范围是 $0000H \sim 07FFH$，则其片选信号由A15-A11等于 \_\_\_\_\_\_\_\_\_\_ (二进制)时产生。
53. 在P23-24用6116组成8KB RAM的部分译码法示例中，如果CPU的A11, A12, A13地址线未使用，则会导致每个芯片有  \_\_\_\_\_\_\_\_\_\_ 个地址重叠区。

---

**答案区 (请独立完成后对照)**

1.  存储器
2.  小, 高
3.  外存
4.  内存, 易失
5.  毫秒 (ms), 纳秒 (ns)
6.  ROM (只读存储器)
7.  静态 (Static), 触发器
8.  动态 (Dynamic), 电容
9.  紫外线 (Erasable)
10. 块
11. 易失 (Volatility)
12. 不需要
13. 刷新 (Refresh)
14. 非易失 (Non-volatility)
15. 掩膜 (Mask)
16. EPROM
17. 触发器
18. 不需要
19. 需要
20. 主内存(大容量)
21. 容量 (Capacity)
22. 每单元数据位数 (字长)
23. 地址
24. 数据
25. 4
26. 时间 (或 存取时间)
27. 存储体 (Memory Array/Matrix)
28. 地址译码器 (Address Decoder)
29. 三态数据 (Tri-state Data)
30. 11
31. 片选 (Chip Select / Chip Enable)
32. 写 (Write)
33. 1
34. 高阻 (High Impedance)
35. 片选 ($\overline{CS}$)
36. 内部
37. 片选译码
38. $\overline{OE}$ (Output Enable)
39. 位数 (位扩展)
40. 并联
41. D4-D7
42. 字数 (字扩展)
43. 并联
44. 高位
45. 2-4译码器 (或 译码器)
46. 位字双重 (或 字位双重)
47. 唯一确定 (或 无重叠)
48. 地址重叠
49. 最简单 (或 简单)
50. 低
51. A0-A10 (或 地址输入)
52. 00000
53. 8

---
# 第6章 I/O接口与8255 - 填空题

**6.1 I/O接口的功能**

1.  计算机与外设间交换数据、状态和控制命令的过程统称为 \_\_\_\_\_\_\_\_\_\_。
2.  **CPU与外设之间在速度、\_\_\_\_\_\_\_\_\_\_、信号格式和时序等方面存在差异，因此不能直接相连。
3.  CPU速度远高于外设，且不同外设速度差异大，这是指 \_\_\_\_\_\_\_\_\_\_ 不匹配。
4.  CPU常传送并行数据，而外设信息格式多样（如模拟量、串行数据），这是指 \_\_\_\_\_\_\_\_\_\_ 不匹配。
5.  输入输出设备必须通过设置专门的 \_\_\_\_\_\_\_\_\_\_ 电路来解决与CPU之间的不匹配问题。
6.  接口通过设置数据缓冲（如锁存器、三态缓冲器）来解决 \_\_\_\_\_\_\_\_\_\_ 不匹配的问题。
7.  接口通过设置电平转换电路（如MAX232）来解决 \_\_\_\_\_\_\_\_\_\_ 不一致的问题。
8.  接口通过使用A/D或D/A转换器来满足外设与计算机各自的 \_\_\_\_\_\_\_\_\_\_ 要求。
9.  接口通过设置时序控制电路，并常使用 \_\_\_\_\_\_\_\_\_\_ 联络信号来同步CPU和外设的工作。
10. 接口电路通过 \_\_\_\_\_\_\_\_\_\_ 电路选中目标端口，其I/O地址由该电路提供。
11. I/O接口电路是外设与计算机之间传送信息的 \_\_\_\_\_\_\_\_\_\_ 部件，起协调作用。
12. 随着VLSI技术发展，出现了许多通用 \_\_\_\_\_\_\_\_\_\_ 接口芯片，方便构成接口电路。

**6.2 I/O端口及其寻址方式**

13. **CPU与外设通信时，主要传送的三类信息是：数据信息、\_\_\_\_\_\_\_\_\_\_ 信息和控制信息。
14. 在接口电路中，用于暂存数据、状态和控制信息的寄存器及其控制逻辑统称为 \_\_\_\_\_\_\_\_\_\_。
15. I/O端口按功能可分为数据端口、\_\_\_\_\_\_\_\_\_\_ 端口和控制/命令端口。
16. 用于存放外设送往CPU的数据或CPU输出到外设的数据的端口是 \_\_\_\_\_\_\_\_\_\_ 端口。
17. 指示外设当前状态的端口是 \_\_\_\_ 端口，其内容包含若干状态位。
18. 状态端口中，表示输入数据已准备好等待CPU读取，或输出数据寄存器已空可接收新数据的状态位是 \_\_\_\_\_\_\_\_\_\_ 位。
19. 状态端口中，表示外设正忙于I/O传送，CPU暂时不能发送新数据的状态位是 \_\_\_\_\_\_\_\_\_\_ 位。
20. 状态端口中，表示数据传送中发生错误（如奇偶校验错）的状态位是 \_\_\_\_\_\_\_\_\_\_ 位。
21. 用于存放CPU向接口发出的各种命令和控制字，以控制接口或设备动作的端口是 \_\_\_\_\_\_\_\_\_\_ 端口。
22. 命令端口中常见的命令位有启动位、停止位和允许 \_\_\_\_\_\_\_\_\_\_ 位等。
23. **把I/O端口看作存储单元，与内存单元统一编址的寻址方式称为 \_\_\_\_\_\_\_\_\_\_ 寻址方式。
24. 存储器映象寻址方式的优点是所有访问 \_\_\_\_\_\_\_\_\_\_ 的指令都可访问I/O端口。
25. 存储器映象寻址方式的缺点是I/O端口占用 \_\_\_\_\_\_\_\_\_\_ 地址空间。
26. I/O端口地址单独编址，形成独立的I/O地址空间的方式称为I/O \_\_\_\_\_\_\_\_\_\_ 编址方式。
27. I/O单独编址方式使用专门的 \_\_\_\_\_\_\_\_\_\_ 和 \_\_\_\_\_\_\_\_\_\_ 指令访问端口。
28. I/O单独编址方式的优点之一是I/O端口不占用 \_\_\_\_\_\_\_\_\_\_ 空间。
29. Intel 8086/8088系统采用的是I/O \_\_\_\_\_\_\_\_\_\_ 编址方式。

**6.3 CPU与外设间的数据传送方式**

30. **CPU与外设间的数据传送方式主要有程序控制方式、\_\_\_\_\_\_\_\_\_\_ 方式和DMA方式。
31. 程序控制方式下，数据传送分为无条件传送和 \_\_\_\_\_\_\_\_\_\_ 传送（查询方式）。
32. 当外设准备好后发出中断请求，CPU响应中断后在 \_\_\_\_\_\_\_\_\_\_ 中完成数据传送的方式是中断方式。
33. 由DMA控制器临时接管总线控制权，实现外设与存储器之间直接高速数据传送的方式是 \_\_\_\_\_\_\_\_\_\_ 方式。
34. 无条件传送方式也称为 \_\_\_\_\_\_\_\_\_\_ 传送方式，它假设外设总是准备好的。
35. 在最简单输入口电路中，CPU执行 \_\_\_\_\_\_\_\_\_\_ 指令即可随时读取开关状态。
36. 条件传送方式（查询方式）中，CPU在传送数据前，先执行IN指令读取外设的 \_\_\_\_\_\_\_\_\_\_ 端口。
37. 查询式输入电路中，当输入设备准备好数据后，会置位一个 \_\_\_\_\_\_\_\_\_\_ 信号（状态位）。
38. 在图6.5的查询输入程序示例中，`TEST AL, 01H` 指令用于测试 \_\_\_\_\_\_\_\_\_\_ 位是否为1。**（test执行按位与操作）
39. 查询式输出电路中，CPU检查外设的 \_\_\_\_\_\_\_\_\_\_ 状态位，若为0（空闲）才输出数据。
40. 查询方式的主要缺点是CPU需要花费大量时间循环等待，\_\_\_\_\_\_\_\_\_\_ 很低。
41. 中断方式下，当输入设备准备好数据或输出端口空闲时，外设主动向CPU发出 \_\_\_\_\_\_\_\_\_\_。
42. DMA方式的核心部件是 \_\_\_\_\_\_\_\_\_\_ 控制器 (DMAC)。
43. 在DMA传送过程中，DMAC临时接管总线，实现外设与存储器之间的数据传送，\_\_\_\_\_\_\_\_\_\_ (需要/无需) CPU干预。
44. DMA传送结束后，DMAC会 \_\_\_\_\_\_\_\_\_\_ 总线，将控制权交还给CPU。
45. DMAC能给出访问内存所需的地址信息，并能设定和修改本次传送的 \_\_\_\_\_\_\_\_\_\_。

**程序示例相关填空**

```assembly
; 查询式输入程序段示例 (部分)
READ_S1:
    IN   AL, PORT_S1  ; 读入状态位到AL
    TEST AL, 01H      ; 测试READY位 (假设在bit 0) 是否为1?
    ______   READ_S1  ; 若为0 (未准备好), 跳转回去继续查询
; --- 数据准备好 ---
    IN   AL, PORT_IN
    MOV  [BX], AL
    INC  BX
    LOOP READ_S1
```
46. 上述查询输入程序中，若READY位为0，则应使用 \_\_\_\_\_\_\_\_\_\_ 指令跳转回 `READ_S1`。

```assembly
; 查询式输出程序段示例 (部分)
READ_S2:
    IN   AL, PORT_S2  ; 读入状态位到AL
    TEST AL, 02H      ; 测试BUSY位 (假设在bit 1) 是否为1?
    ______  READ_S2   ; 若为1 (忙), 跳转回去继续查询
; --- 外设不忙 ---
    MOV  AL, data
    OUT  PORT_OUT, AL
    LOOP READ_S2
```
47. 上述查询输出程序中，若BUSY位为1，则应使用 \_\_\_\_\_\_\_\_\_\_ 指令跳转回 `READ_S2`。

---

**答案区 (请独立完成后对照)**

1.  通信
2.  信号电平
3.  速度
4.  信号格式
5.  接口 (Interface)
6.  速度
7.  信号电平
8.  信息格式
9.  握手联络 (handshaking)
10. 地址译码
11. 交接
12. 可编程
13. 状态
14. I/O端口 (Port)
15. 状态
16. 数据
17. 状态
18. 准备就绪 (Ready)
19. 忙碌 (Busy)
20. 错误 (Error)
21. 命令 (Command) / 控制 (Control)
22. 中断
23. 存储器映象 (Memory Mapped I/O)
24. 存储器
25. 存储器 (内存)
26. 单独 (Isolated I/O / I/O Mapped I/O)
27. IN, OUT
28. 内存
29. 单独 (或 独立)
30. 中断
31. 条件
32. 中断服务程序
33. DMA (直接存储器存取)
34. 同步
35. IN
36. 状态
37. READY (或 准备就绪)
38. READY (或 准备就绪 / bit 0)
39. BUSY (或 忙碌)
40. 效率
41. 中断请求
42. DMA
43. 无需
44. 释放
45. 字节数 (或 传送计数)
46. JZ (Jump if Zero)
47. JNZ (Jump if Not Zero)


---

# 第7章 可编程并行接口8255 - 填空题

**1. 并行通信与并行接口**

1.  将数据的各位同时在多根并行传输线上进行传输的通信方式称为 \_\_\_\_\_\_\_\_\_\_ 通信。
2.  并行通信适合于外部设备与微机之间进行近距离、\_\_\_\_\_\_\_\_\_\_ 和快速的信息交换。
3.  连接CPU与并行外设，实现两者间并行通信的电路称为 \_\_\_\_\_\_\_\_\_\_ 接口。
4.  **并行接口在信息传送过程中起到输出 \_\_\_\_\_\_\_\_\_\_ 或输入 \_\_\_\_\_\_\_\_\_\_ 的作用。

**2. 8255A的内部结构和引脚**

5.  8255A是一款通用的可编程 \_\_\_\_\_\_\_\_\_\_ 接口芯片。
6.  **8255A内部连接CPU数据总线 ($D_0 \sim D_7$) 的部件是8位双向三态 \_\_\_\_\_\_\_\_\_\_。
7.  8255A内部接收CPU控制信号（如 $\overline{RD}, \overline{WR}, A_1, A_0, \overline{CS}$）的部件是 \_\_\_\_\_\_\_\_\_\_ 逻辑。
8.  8255A有三个并行端口，分别是端口A、端口B和端口 \_\_\_\_\_\_\_\_\_\_。
9.  8255A的端口C可分为高4位 (PC4-PC7) 和 \_\_\_\_\_\_\_\_\_\_ (PC0-PC3)。
10. **8255A与CPU接口的引脚包括数据线 $D_0 \sim D_7$ 和控制线，如 $\overline{CS}$、$\overline{RD}$、$\overline{WR}$ 以及地址选择线 \_\_\_\_\_\_\_\_\_\_ 和 \_\_\_\_\_\_\_\_\_\_。

**3. 8255A内部组成详解**

11. 8255A与外设接口部分包含的三个8位输入输出端口是 \_\_\_\_\_\_\_\_\_\_、\_\_\_\_\_\_\_\_\_\_ 和 \_\_\_\_\_\_\_\_\_\_。
12. 8255A的内部控制部分由A组和 \_\_\_\_\_\_\_\_\_\_ 组两组控制电路组成。
13. 8255A的A组控制电路控制端口A和端口C的 \_\_\_\_\_\_\_\_\_\_ (PC4-PC7)。
14. 8255A的B组控制电路控制端口B和端口C的 \_\_\_\_\_\_\_\_\_\_ (PC0-PC3)。
15. 8255A的内部控制电路也可根据控制字的要求对端口C按位进行 \_\_\_\_\_\_\_\_\_\_ 或 \_\_\_\_\_\_\_\_\_\_。

**4. 8255A端口选择和基本操作**

16. CPU通过地址线 $A_1, A_0$ 和控制信号来选择8255A的端口并进行读写，当 $A_1 A_0 = 00$ 时，选择的是端口 \_\_\_\_\_\_\_\_\_\_。
17. 当 $A_1 A_0 = 01$ 且 $\overline{RD}=1, \overline{WR}=0, \overline{CS}=0$ 时，执行的操作是向端口 \_\_\_\_\_\_\_\_\_\_ 写入数据。
18. 当 $A_1 A_0 = 10$ 且 $\overline{RD}=0, \overline{WR}=1, \overline{CS}=0$ 时，执行的操作是从端口 \_\_\_\_\_\_\_\_\_\_ 读取数据。
19. **向8255A写入控制字时，$A_1 A_0$ 的状态应为 \_\_\_\_\_\_\_\_\_\_。
20. 当8255A的 $\overline{CS}$ 引脚为 \_\_\_\_\_\_\_\_\_\_ (高/低) 电平时，芯片才被选中。
21. 8255A的控制寄存器是 \_\_\_\_\_\_\_\_\_\_ (可读/不可读) 的。

**5. 8255A的工作方式**

22. 8255A的方式0是基本输入输出方式，适用于 \_\_\_\_\_\_\_\_\_\_ 传送和查询方式的接口电路。
23. 8255A的方式1是 \_\_\_\_\_\_\_\_\_\_ 输入输出方式，端口C的位用于提供应答联络信号。
24. 8255A的方式2是双向选通传送方式，只有端口 \_\_\_\_\_\_\_\_\_\_ 可以工作于此方式。

**6. 8255A的编程**

25. 对8255A进行初始化编程的目的是设定各个数据端口的工作方式和 \_\_\_\_\_\_\_\_\_\_ 方向。
26. **初始化8255A时，需要向其控制端口（$A_1 A_0 = 11$）写入一个 \_\_\_\_\_\_\_\_\_\_ 控制字。
27. 在8255A工作过程中，CPU通过输入/输出指令对选定的 \_\_\_\_\_\_\_\_\_\_ 端口进行读写操作。

**7. 控制字格式**

28. 8255A的控制字通过其最高位 \_\_\_\_\_\_\_\_\_\_ 来区分是方式选择控制字还是端口C按位置位/复位控制字。
29. 当控制字的 $D_7=1$ 时，它是一个 \_\_\_\_\_\_\_\_\_\_ 控制字。
30. 方式选择控制字中，$D_4$ 位用于设置端口A的 \_\_\_\_\_\_\_\_\_\_ (0:输出, 1:输入)。
31. 方式选择控制字中，$D_2$ 位用于设置B组的工作方式，0表示方式 \_\_\_\_\_\_\_\_\_\_，1表示方式 \_\_\_\_\_\_\_\_\_\_。
32. 方式选择控制字中，端口C的PC0-PC3方向位 ($D_0$) 仅在B组工作于方式 \_\_\_\_\_\_\_\_\_\_ 时有效。
33. 当控制字的 $D_7=0$ 时，它是一个端口C按位 \_\_\_\_\_\_\_\_\_\_ / \_\_\_\_\_\_\_\_\_\_ 控制字。
34. 端口C按位置位/复位控制字中，$D_3 D_2 D_1$ 位用于选择要操作的端口C的 \_\_\_\_\_\_\_\_\_\_。
35. 端口C按位置位/复位控制字中，$D_0=1$ 表示执行 \_\_\_\_\_\_\_\_\_\_ 操作。

**8. 8255A控制字举例**

36. 若要求8255A工作于方式0，A口输入，B口输出，C口高4位输入，低4位输出，则方式选择控制字为 $10011000_B$，即 \_\_\_\_\_\_\_\_\_\_H。
37. 承上例，若要使C口的PC3置1，则应向控制口写入按位操作控制字 $0xxx0111_B$，即 \_\_\_\_\_\_\_\_\_\_H。

**9. 方式0详解 (基本输入输出方式)**

38. **8255A在方式0下，所有输出口均有 \_\_\_\_\_\_\_\_\_\_ 能力。
39. 8255A在方式0下，输入口只有缓冲能力，\_\_\_\_\_\_\_\_\_\_ (有/无) 锁存能力。
40. 在方式0下进行查询传送时，端口C的若干位可被用作 \_\_\_\_\_\_\_\_\_\_ 查询位或控制信号位。

**10. 方式0应用实例**

41. 在P13的开关与LED控制代码示例中，`MOV DX, 281H` 后 `IN AL, DX` 是为了读取端口 \_\_\_\_\_\_\_\_\_\_ 的状态。
42. 在P13的示例中，将C口低4位开关状态用于控制C口高4位LED，需要使用 \_\_\_\_\_\_\_\_\_\_ 指令将AL中的数据左移4位。
43. 在P15-16的监控与报警系统示例中，当检测到A口非0（异常）时，程序通过循环3次置位和复位端口C的PC0位来使报警灯 \_\_\_\_\_\_\_\_\_\_。
44. 在P15-16的示例中，置位PC0的按位操作控制字是 $00000001_B$，复位PC0的控制字是 \_\_\_\_\_\_\_\_\_\_。
45. 在P17-19的开关与七段数码管示例中，读取A口开关状态后，通常用 \_\_\_\_\_\_\_\_\_\_ 指令屏蔽高4位，然后用 \_\_\_\_\_\_\_\_\_\_ 指令查表获取七段码。

**11. 8086系统中8255端口地址确定**

46. **在8086系统中，若8255的 $D_0 \sim D_7$ 连接到CPU的 $D_0 \sim D_7$ (低8位)，则CPU访问8255时使用的是 \_\_\_\_\_\_\_\_\_\_ 地址。
47. 在8086系统中，若8255的 $D_0 \sim D_7$ 连接到CPU的 $D_8 \sim D_{15}$ (高8位)，则CPU访问8255时使用的是 \_\_\_\_\_\_\_\_\_\_ 地址。
48. 在P20-21的8086系统8255地址确定示例中，若CPU的 $A_1, A_2$ 连接到8255的 $A_0, A_1$，且片选条件使得基地址的CPU $A_0$ 为0，则端口A的CPU地址为 $F0H$，端口B的CPU地址为 \_\_\_\_\_\_\_\_\_\_H。

---

**答案区 (请独立完成后对照)**

1.  并行
2.  大量
3.  并行
4.  锁存, 缓冲
5.  并行
6.  数据总线缓冲器
7.  读写控制
8.  C
9.  低4位
10. A1, A0
11. 端口A, 端口B, 端口C
12. B
13. 高4位
14. 低4位
15. 置位, 复位
16. A
17. B
18. C
19. 11
20. 低
21. 不可读
22. 无条件
23. 选通
24. A
25. 输入/输出 (I/O)
26. 方式选择
27. 数据
28. $D_7$
29. 方式选择
30. 输入/输出方向
31. 0, 1
32. 0
33. 置位, 复位
34. 位 (bit)
35. 置位
36. 98
37. 07
38. 锁存
39. 无
40. 状态
41. B
42. SHL (或 SAL)
43. 闪烁 (亮灭)
44. $00000000_B$ (或 00H)
45. AND, XLAT
46. 偶
47. 奇
48. F2

---

# 第8章 中断和8259A - 填空题 

**8.1.1 中断概念和分类**

1.  计算机在执行正常程序过程中，因遇到内部或外部的紧急事件或预定事件，暂时中止当前程序的执行，转而去执行为该事件准备的 \_\_\_\_\_\_\_\_\_\_，处理完毕后自动返回到原来被中止的程序处继续执行的过程称为中断。
2.  中断功能之一是实现CPU与外设 \_\_\_\_\_\_\_\_\_\_ 工作，提高CPU利用率。
3.  中断功能之二是实现 \_\_\_\_\_\_\_\_\_\_ 处理，如及时响应现场数据，避免丢失。
4.  通过 `INT n` 指令调用操作系统或BIOS提供的服务程序，是中断功能在提供 \_\_\_\_\_\_\_\_\_\_ 途径方面的体现。
5.  引起中断的原因或发出中断请求的来源称为 \_\_\_\_\_\_\_\_\_\_。
6.  8086的中断主要分为外部中断（硬件中断）和 \_\_\_\_\_\_\_\_\_\_ 中断（软件中断或异常）两大类。
7.  通过NMI引脚引入，优先级高，不受中断标志位IF影响的中断是 \_\_\_\_\_\_\_\_\_\_ 中断。
8.  通过INTR引脚引入，受CPU标志寄存器中的中断允许标志位 \_\_\_\_\_\_\_\_\_\_ 控制的中断是可屏蔽中断。
9.  当 `IF=0` 时，CPU \_\_\_\_\_\_\_\_\_\_ (允许/禁止) 响应INTR请求。
10. 执行除法指令（`DIV`, `IDIV`）时，若除数为0或商超出容量，会产生类型号为 \_\_\_\_\_\_\_\_\_\_ 的 \_\_\_\_\_\_\_\_\_\_ 错中断。
11. 当标志寄存器中的陷阱标志位 \_\_\_\_\_\_\_\_\_\_ = 1 时，每执行完一条指令就产生一次单步中断（类型1）。
12. 执行 `INTO` 指令时，若溢出标志位 `OF=1`，则产生类型号为 \_\_\_\_\_\_\_\_\_\_ 的溢出中断。
13. 执行 `INT n` 指令直接引发的中断称为 \_\_\_\_\_\_\_\_\_\_ 中断，n是中断类型号。
14. 执行 `INT 3` 指令引发的中断是类型3的 \_\_\_\_\_\_\_\_\_\_ 中断，常用于调试。
15. INTR中断请求通常连接到可编程中断控制器如 \_\_\_\_\_\_\_\_\_\_，它负责管理多个外部设备的中断请求。
16. CPU响应中断时，会自动将FLAGS寄存器、\_\_\_\_\_\_\_\_\_\_ 寄存器和IP寄存器的值依次压入堆栈。
17. CPU根据中断类型号n找到对应的中断服务程序入口地址，这个入口地址称为 \_\_\_\_\_\_\_\_\_\_。
18. 中断服务程序结束时，执行 \_\_\_\_\_\_\_\_\_\_ 指令，CPU会自动从堆栈中弹出IP、CS、FLAGS的值。
19. 8086 CPU支持256种中断，对应的中断向量集中存放在内存最低地址区域 $00000H \sim$ \_\_\_\_\_\_\_\_\_\_，这个区域称为中断向量表。
20. 每个中断向量占用 \_\_\_\_\_\_\_\_\_\_ 字节，低地址存放 \_\_\_\_\_\_\_\_\_\_ (IP/CS)，高地址存放 \_\_\_\_\_\_\_\_\_\_ (IP/CS)。
21. 给定中断类型号n，其中断向量在IVT中的起始地址为 n × \_\_\_\_\_\_\_\_\_\_。
22. 类型号为 $44H$ 的中断，其服务程序入口地址为 $3600:2000H$，则在中断向量表地址 $0110H$ 处存放的是 $00H$，地址 $0111H$ 处存放的是 \_\_\_\_\_\_\_\_\_\_，地址 $0113H$ 处存放的是 $36H$。
23. 当多个中断同时请求时，CPU响应中断的优先次序称为中断 \_\_\_\_\_\_\_\_\_\_。
24. 8086中断优先级中，NMI的优先级 \_\_\_\_\_\_\_\_\_\_ (高于/低于) INTR。
25. 8086中断优先级中，单步中断(TF)的优先级是 \_\_\_\_\_\_\_\_\_\_ (最高/最低)。
26. 一个高优先级的中断请求打断了正在执行的低优先级中断服务程序的过程称为中断 \_\_\_\_\_\_\_\_\_\_。
27. CPU进入任何中断服务程序后，硬件会自动清除 \_\_\_\_\_\_\_\_\_\_ 标志位（关中断）。
28. 如果希望允许更高优先级的可屏蔽中断嵌套，中断服务程序必须执行 \_\_\_\_\_\_\_\_\_\_ 指令开中断。

**8.1.2 中断的响应与处理过程**

29. CPU在每条指令执行结束后，按特定顺序检查是否有中断请求发生，这个阶段称为中断 \_\_\_\_\_\_\_\_\_\_。
30. 对于INTR中断，CPU需要执行两个连续的 \_\_\_\_\_\_\_\_\_\_ 总线周期来从中断控制器获取类型号n。
31. 在第二个 $\overline{INTA}$ 周期，中断控制器将中断源对应的类型号n放到 \_\_\_\_\_\_\_\_\_\_ 总线上，供CPU读取。
32. 中断处理的硬件自动操作中，除了压栈FLAGS, CS, IP外，还会清除IF和 \_\_\_\_\_\_\_\_\_\_ 标志位。
33. 清除IF标志是为了 \_\_\_\_\_\_\_\_\_\_，防止在进入服务程序时尚未准备好时被其他INTR中断打扰。
34. CPU从IVT中取出中断向量后，将其装入CS和 \_\_\_\_\_\_\_\_\_\_ 寄存器，从而跳转到中断服务程序。
35. 中断服务程序 (ISR) 的任务通常包括保护现场、\_\_\_\_\_\_\_\_\_\_、可选的开中断和恢复现场。
36. 中断返回指令 `IRET` 会自动恢复中断发生前 \_\_\_\_\_\_\_\_\_\_ 寄存器的状态，因此中断结束前通常不需要显式开中断。

---

**答案区 (请独立完成后对照)**

1.  中断处理程序 (或 中断服务程序)
2.  并行
3.  实时
4.  系统调用
5.  中断源
6.  内部
7.  NMI (不可屏蔽)
8.  IF (中断允许标志位)
9.  禁止
10. 0, 除法
11. TF (陷阱标志位)
12. 4
13. 软件
14. 断点
15. 8259A
16. CS (代码段)
17. 中断向量
18. IRET
19. 003FFH
20. 4, IP, CS
21. 4
22. 20H
23. 优先级
24. 高于
25. 最低
26. 嵌套
27. IF (中断允许标志位)
28. STI (Set Interrupt Flag)
29. 查询
30. 中断响应 ($\overline{INTA}$)
31. 数据
32. TF (陷阱标志位)
33. 关中断
34. IP (指令指针)
35. 中断服务 (具体处理任务)
36. FLAGS (标志)